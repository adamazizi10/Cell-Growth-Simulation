{"ast":null,"code":"export let CellType = /*#__PURE__*/function (CellType) {\n  CellType[CellType[\"Alive\"] = 0] = \"Alive\";\n  CellType[CellType[\"Dead\"] = 1] = \"Dead\";\n  return CellType;\n}({});\nexport const createEmptyGrid = (rows, cols) => {\n  const grid = Array.from({\n    length: rows\n  }, () => Array.from({\n    length: cols\n  }, () => CellType.Dead));\n  const centerRow = Math.floor(rows / 2);\n  const centerCol = Math.floor(cols / 2);\n  grid[centerRow][centerCol] = CellType.Alive;\n  return grid;\n};\nexport const simulateCellGrowth = (grid, rows, cols) => {\n  const newGrid = grid.map(row => [...row]);\n  const activeCells = [];\n\n  // Gather all currently alive cells\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === CellType.Alive) {\n        activeCells.push({\n          row: i,\n          col: j\n        });\n      }\n    }\n  }\n\n  // Process only active cells\n  for (const {\n    row,\n    col\n  } of activeCells) {\n    if (row > 0 && grid[row - 1][col] === CellType.Dead) newGrid[row - 1][col] = CellType.Alive;\n    if (row < rows - 1 && grid[row + 1][col] === CellType.Dead) newGrid[row + 1][col] = CellType.Alive;\n    if (col > 0 && grid[row][col - 1] === CellType.Dead) newGrid[row][col - 1] = CellType.Alive;\n    if (col < cols - 1 && grid[row][col + 1] === CellType.Dead) newGrid[row][col + 1] = CellType.Alive;\n  }\n  return newGrid;\n};","map":{"version":3,"names":["CellType","createEmptyGrid","rows","cols","grid","Array","from","length","Dead","centerRow","Math","floor","centerCol","Alive","simulateCellGrowth","newGrid","map","row","activeCells","i","j","push","col"],"sources":["/Users/adamazizi/Desktop/nicehellohi/Cell-Growth-Simulation/src/utils/utils.ts"],"sourcesContent":["export enum CellType {\n  Alive,\n  Dead,\n}\n\nexport const createEmptyGrid = (rows: number, cols: number): CellType[][] => {\n  const grid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => CellType.Dead));\n  const centerRow = Math.floor(rows / 2);\n  const centerCol = Math.floor(cols / 2);\n  grid[centerRow][centerCol] = CellType.Alive;\n  return grid;\n};\n\n\ntype Cell = { row: number, col: number };\n\nexport const simulateCellGrowth = (grid: CellType[][], rows: number, cols: number): CellType[][] => {\n  const newGrid = grid.map(row => [...row]);\n  const activeCells: Cell[] = [];\n\n  // Gather all currently alive cells\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === CellType.Alive) {\n        activeCells.push({ row: i, col: j });\n      }\n    }\n  }\n\n  // Process only active cells\n  for (const { row, col } of activeCells) {\n    if (row > 0 && grid[row - 1][col] === CellType.Dead) newGrid[row - 1][col] = CellType.Alive;\n    if (row < rows - 1 && grid[row + 1][col] === CellType.Dead) newGrid[row + 1][col] = CellType.Alive;\n    if (col > 0 && grid[row][col - 1] === CellType.Dead) newGrid[row][col - 1] = CellType.Alive;\n    if (col < cols - 1 && grid[row][col + 1] === CellType.Dead) newGrid[row][col + 1] = CellType.Alive;\n  }\n  \n  return newGrid;\n};\n"],"mappings":"AAAA,WAAYA,QAAQ,0BAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAAA,OAARA,QAAQ;AAAA;AAKpB,OAAO,MAAMC,eAAe,GAAGA,CAACC,IAAY,EAAEC,IAAY,KAAmB;EAC3E,MAAMC,IAAI,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEL;EAAK,CAAC,EAAE,MAAMG,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEJ;EAAK,CAAC,EAAE,MAAMH,QAAQ,CAACQ,IAAI,CAAC,CAAC;EAClG,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACT,IAAI,GAAG,CAAC,CAAC;EACtC,MAAMU,SAAS,GAAGF,IAAI,CAACC,KAAK,CAACR,IAAI,GAAG,CAAC,CAAC;EACtCC,IAAI,CAACK,SAAS,CAAC,CAACG,SAAS,CAAC,GAAGZ,QAAQ,CAACa,KAAK;EAC3C,OAAOT,IAAI;AACb,CAAC;AAKD,OAAO,MAAMU,kBAAkB,GAAGA,CAACV,IAAkB,EAAEF,IAAY,EAAEC,IAAY,KAAmB;EAClG,MAAMY,OAAO,GAAGX,IAAI,CAACY,GAAG,CAACC,GAAG,IAAI,CAAC,GAAGA,GAAG,CAAC,CAAC;EACzC,MAAMC,WAAmB,GAAG,EAAE;;EAE9B;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,IAAI,EAAEiB,CAAC,EAAE,EAAE;IAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,IAAI,EAAEiB,CAAC,EAAE,EAAE;MAC7B,IAAIhB,IAAI,CAACe,CAAC,CAAC,CAACC,CAAC,CAAC,KAAKpB,QAAQ,CAACa,KAAK,EAAE;QACjCK,WAAW,CAACG,IAAI,CAAC;UAAEJ,GAAG,EAAEE,CAAC;UAAEG,GAAG,EAAEF;QAAE,CAAC,CAAC;MACtC;IACF;EACF;;EAEA;EACA,KAAK,MAAM;IAAEH,GAAG;IAAEK;EAAI,CAAC,IAAIJ,WAAW,EAAE;IACtC,IAAID,GAAG,GAAG,CAAC,IAAIb,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACK,GAAG,CAAC,KAAKtB,QAAQ,CAACQ,IAAI,EAAEO,OAAO,CAACE,GAAG,GAAG,CAAC,CAAC,CAACK,GAAG,CAAC,GAAGtB,QAAQ,CAACa,KAAK;IAC3F,IAAII,GAAG,GAAGf,IAAI,GAAG,CAAC,IAAIE,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACK,GAAG,CAAC,KAAKtB,QAAQ,CAACQ,IAAI,EAAEO,OAAO,CAACE,GAAG,GAAG,CAAC,CAAC,CAACK,GAAG,CAAC,GAAGtB,QAAQ,CAACa,KAAK;IAClG,IAAIS,GAAG,GAAG,CAAC,IAAIlB,IAAI,CAACa,GAAG,CAAC,CAACK,GAAG,GAAG,CAAC,CAAC,KAAKtB,QAAQ,CAACQ,IAAI,EAAEO,OAAO,CAACE,GAAG,CAAC,CAACK,GAAG,GAAG,CAAC,CAAC,GAAGtB,QAAQ,CAACa,KAAK;IAC3F,IAAIS,GAAG,GAAGnB,IAAI,GAAG,CAAC,IAAIC,IAAI,CAACa,GAAG,CAAC,CAACK,GAAG,GAAG,CAAC,CAAC,KAAKtB,QAAQ,CAACQ,IAAI,EAAEO,OAAO,CAACE,GAAG,CAAC,CAACK,GAAG,GAAG,CAAC,CAAC,GAAGtB,QAAQ,CAACa,KAAK;EACpG;EAEA,OAAOE,OAAO;AAChB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}